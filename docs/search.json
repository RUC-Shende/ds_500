[
  {
    "objectID": "weeks7-8.html",
    "href": "weeks7-8.html",
    "title": "Weeks 7 and 8",
    "section": "",
    "text": "Using an IDE for developing code in modules.\nPractice with recursion and designing recursive functions.\nIntroduction to Code Testing (using pytest)"
  },
  {
    "objectID": "weeks7-8.html#outline",
    "href": "weeks7-8.html#outline",
    "title": "Weeks 7 and 8",
    "section": "",
    "text": "Using an IDE for developing code in modules.\nPractice with recursion and designing recursive functions.\nIntroduction to Code Testing (using pytest)"
  },
  {
    "objectID": "weeks7-8.html#ides-for-code-development",
    "href": "weeks7-8.html#ides-for-code-development",
    "title": "Weeks 7 and 8",
    "section": "2 IDEs for Code Development",
    "text": "2 IDEs for Code Development\nWhile Jupyter notebooks are a great way to experiment with code snippets and to provide annotations and explanatory commentary on the code, it is usually better to develop the code in the form of Python modules (.py files).\nOnce modules are defined, their namespaces (defined objects, functions, classes etc.) can be imported in other modules or even in a Jupyter notebook!\n\n2.1 Popular IDEs\nThere are several Integrated Development Environments (IDEs) where Python code for modules that are part of a project or package can be developed, executed, debugged and tested. IDEs also provide support for formatting the code, in a manner similar to what the notebook code cells do.\nAmong the most popular IDEs are the following:\n\nIDLE: the native, frills-free IDE that comes bundled with every Python installation\nPyCharm: a proprietary IDE\nVS Code: an industry standard IDE\nSpyder: part of the Anaconda distribution but can also be installed separately."
  },
  {
    "objectID": "weeks7-8.html#recursion",
    "href": "weeks7-8.html#recursion",
    "title": "Weeks 7 and 8",
    "section": "3 Recursion",
    "text": "3 Recursion\nA recursive function is defined in terms of itself; more specifically:\n\nit is defined without further self-reference for the base case(s) of the argument, viz. when the arguments are small enough.\nfor larger arguments, it is defined in terms of its values on specific smaller arguments.\n\n\n\n\n\n\n\nNote\n\n\n\nMost recursive functions have base cases associated with the small integers 0, 1, 2 etc. The larger arguments are associated with larger integers: see, for example, the recursive function definition below.\n\n\n\n3.1 Example 1: Factorial\nConsider the factorial function defined for all n \\geq 0 as: f(n) = n \\cdot (n-1) \\cdot (n-2) \\ldots 1\nObserve that the definition is understood by a human reader as saying: Form the product of successive descending numbers starting from n, then (n-1), then (n-2) and so on going down to 1!\nA recursive specification would instead say that f(1) equals 1 for the base case when n=1. For larger values of n, we multiply n with the result of the recursive computation f(n-1) to obtain f(n). Here is what the code might look like:\n\n\nCode\ndef f(n: int) -&gt; int:\n    \"\"\"Returns the factorial of n &gt;= 1\n    \"\"\"\n    if n == 1:\n        return 1\n    return n * f(n-1)\n\n\nTwo observations can be made about this example, one generic and one specific.\n\nSpecific: The function exhibits tail-recursion, i.e. the stack of successive recursive function calls unwinds completely after the base case has been reached! Such function definitions can easily be converted to loops! See the code below:\n\n\n\nCode\ndef f(n: int) -&gt; int:  # Alternative factorial definition\n    \"\"\"Returns the factorial of n &gt;= 1\"\"\"\n    result = 1\n    for num in reversed(range(1, n+1)):\n        result = num * result\n    return result\n\n\n\nGeneric: Recursive calls are always made to smaller arguments. In this example, it is clear because we are dealing with numbers. In general, the idea of smaller extends to any collection of values that can be well-ordered, namely, values that are totally ordered and have a least element among any subset of elements. See the example below.\n\n\n\n3.2 Example 2: Reversing a string\nLet’s define a recursive Python function to reverse a string. It is based on the observation that the reverse of a string named text is the concatenation of the last symbol text and the reverse of the string obtained by removing the last character of text. Note that this latter string is smaller, viz. it has length 1 less than the length of text. The smallest string is clearly well defined: it is the empty string and happens to be its own reverse.\n\n\nCode\ndef reverse(text: str) -&gt; str:\n    \"\"\"Returns the string obtained by reversing the symbols of text.\"\"\"\n    if len(text) == 0:\n        return text\n    return text[-1] + reverse(text[:-1])\n\n\n\n\n3.3 Exercises\nDefine the following functions recursively. Do not look at the code until you have tried it yourself!\n\nCount the number of transitions in a bitstring, i.e., the number of times we see an instance of 01 or 10 in a string containing just 0s and 1s.\n\n\n\nCode\ndef n_transitions(bitstring: str) -&gt; int:\n    \"\"\"Returns the number of transitions in a non-empty bitstring.\n\n    A transition is an instance of `01` or `10`\n    \"\"\"\n    if len(bitstring) == 0:\n        return 0\n    l_bit = bitstring[0]\n    transition_bit = '0' if l_bit == '1' else '1'\n    posn = bitstring.find(transition_bit)\n    if posn == -1:  # no transition found in bitstring\n        return 0\n    # Count transitions from posn onwards recursively and add 1\n    return 1 + n_transitions(bitstring[posn:])\n\n\n\nReverse the “words” in a string, e.g., recursion is easy becomes easy is recursion. You can assume that any maximal sequence of characters without a whitespace character is a “word”.\n\n\n\n3.4 Example 3: Recursion on one argument\nSuppose we wish to define the multiplication of two integers without being able to use the multiply operator, but only using addition or subtraction.\nLet’s see the reasoning for non-negative integers, and we can then generalize to all integers. There are two arguments, call them a and b. We will recurse only on  b!\n\nWhat is the simplest base case, i.e., where we do not have to rely on any mathematical operation for the result?\nWhat is the simplest general form of the recursive case that allows as to multiply a and b with just addition and the result of a recursive call with a smaller second argument (in place of b)?\n\nOnce you have thought through these questions, try to see if you write a recursive definition based on your answers. One possible solution is below:\n\n\nCode\ndef multiply(a: int, b: int) -&gt; float:\n    \"\"\"Returns a * b.\n    \"\"\"\n    if b == 0:\n        return 0\n    return a + multiply(a, b-1)\n\n\nHere is a similar example of recursing just on one argument. Suppose we wish to compute the result of raising a floating point number to an non-negative integer power.\n\n\nCode\ndef exponentiation(base: float, exponent: int) -&gt; float:\n    \"\"\"Returns base ** exponent.\n    \"\"\"\n    if exponent == 0:\n        return 1\n    return base * exponentiation(base, exponent-1)\n\n\n\n\n3.5 Example 4 (Harder): Partitions of a set into k parts\nA common combinatorial structure is the collection of k-partitions of a set of n objects. In any such partition, every element of the set appears in exactly one part of the partition. For example, we can partition the letters “abcd” into 2 parts in the following three ways: “ab” and “cd”; “ac” and “bd”; “ad” and “bc”. Note that there is no ordering of letters within a part and no ordering among the parts: the partition with parts “ab” and “cd” is the same as that with parts “dc” and “ba”.\nLet’s assume that we are forming partitions of the symbols in a given string with unique symbols (these are the objects in the partitions). To make things even more concrete, each part will be a non-empty string, and each partition will be a tuple of such parts. Finally, any symbols that appear in a part will appear in the same order as in the given string.\nThus, we can say unambiguously that we want our function to create a set containing the seven partitions:\n('a', 'bcd'), ('ab', 'cd'), ('abc', 'd'), ('ac', 'bd'), ('acd', 'b'), ('ad', 'bc'), ('abd', 'c')\nwhen given the arguments 'abcd' and 2, i.e. when it is asked to produce the set of all partitions of size 2 of the four symbols.\nNote that there are two arguments here so we have to be careful about using an ordering of the combined arguments! We can think of the arguments as a tuple: the first a string of some finite length n (the number of symbols/elements of the set) and the second, an integer k indicating the number of parts in a partition.\nThe recursion here comes from a combinatorial argument: any partition of the set of objects b_0, b_1, \\ldots b_{n-1} into k &gt; 1 parts must fall into one of two disjoint categories:\n\nthere is a part which only contains b_0: if we can obtain recursively, the set of partitions of b_1, b_2, \\ldots b_{n-1} into (k-1) parts, we can augment each such partition by adding an additional part that only contains b_0.\nevery part that contains b_0 also contains another object: if we can obtain recursively, the set of partitions of b_1, b_2, \\ldots b_{n-1} into k parts, we can augment each such partition in k ways by inserting b_0 into one of the k parts.\n\nLook carefully at the parameters of the recursive calls, and you observe that in the first case, the call will have as first parameter a smaller set with (n-1) elements and as second parameter, a smaller number of parts (k-1). On the other hand, in the second case, the recursive call will have as first parameter a smaller set with (n-1) elements and as second parameter, the same number of parts k.\nIf we think of the values n and k as forming a tuple, we see that in both cases, we are making a recursive call that features a smaller tuple, where the notion of smaller has to do with lexicographic ordering: e.g. (4,2) is larger than both (3,1) and (3,2); and in turn, (3,2) will be larger than (2,1) and (2,2) etc.\nA little more thought should convince you that the recursion can stop when k=1 or when n=k. In the first instance, we just obtain the one-part partition with all the elements, and in the second, we obtain an n-part partition with singleton elements as parts!\nThe code that formalizes these observations follows quite naturally:\n\n\nCode\ndef partitions(elements: str, k: int) -&gt; set:\n    \"\"\"Returns the list of k-partitions of elements.\n\n    Each part is non-empty!\n\n    Args:\n        elements (str): set represented by a string with unique elements\n        k (int): number of parts in a partition\n\n    Returns:\n        set[tuple[str, ...]]: k-tuples, each with non-empty components\n    \"\"\"\n    if k == 1:  # the first base case\n        return set([elements])\n    if k == len(elements):  # the second base case\n        return set([tuple(elements)])\n    # the recursive argument!\n    result = set()\n    for a_partition in partitions(elements[1:], k-1):  # case 1\n        lst = [elements[0]] + list(a_partition)\n        result.add(tuple(lst))\n    for a_partition in partitions(elements[1:], k):  # case 2\n        for i in range(k):\n            lst = list(a_partition)\n            lst[i] = elements[0] + lst[i]\n            result.add(tuple(lst))\n    return result"
  },
  {
    "objectID": "weeks7-8.html#code-testing",
    "href": "weeks7-8.html#code-testing",
    "title": "Weeks 7 and 8",
    "section": "4 Code Testing",
    "text": "4 Code Testing\nWhether a piece of code runs correctly or not, is based on the specifications for the code. There are essentially three kinds of testing regimens:\n\nBlackbox testing: develop the tests based purely on the specifications. The tests, often called unit tests, can be constructed even before the code is written!\n\nWe will see an example of black-box testing for our partitions function.\n\nInline testing: Unlike traditional testing that is looking for some sort of input-output consistency, inline testing relies on being able to construct invariants associated with the state of the program on a generic input.\nWhitebox testing: This is the kind of testing associated with trying to review code for correctness. As a side-effect, it helps us determine where complexity in the code can be simplified, based on the flow-of-control through the code on various inputs.\n\nIn a large project with multiple functional parts, unit-testing is first applied to individual functions. More robust black-box testing can help identify errors that are caused by integration of various independently developed functions.\n\n4.1 Example: Blackbox testing\nThe simplest way to set up tests is via assert statements where the code checks whether a condition that ought to be true is indeed true as implemented!\nLet’s look at the specification of the partitions function above to try and identify some tests that, if successful on a particular implementation of the function, would give us some confidence in the correctness of the implementation. Here is the docstring:\npartitions(elements: str, k: int) -&gt; set\n    Returns the list of k-partitions of elements.\n\n    Each part is non-empty!\n\n    Args:\n        elements (str): set represented by a string with unique elements\n        k (int): number of parts in a partition\n\n    Returns:\n        set[tuple[str, ...]]: k-tuples, each with non-empty components\n\nTest the boundary case when k equals 1\n\n# All five elements in one part of the 1-partition\npartns1 = partitions('abcde', 1)\nassert len(partns1) == 1\nassert len(partns1.pop()) == 5\n\nTest the boundary case when the size of elements equals k:\n\n# Every element in its own part of the unique 5-partition\npartns2 = partitions('abcde', 5)\nassert len(partns2) == 1\nletters = tuple('abcde')\nsolo_partition = partns2.pop()\nfor letter in tuple('abcde'):\n    assert letter in solo_partition\n\nConsider a case that can be easily analyzed, e.g., all partitions of abcde into 2 parts. Any such partition will have of course have 2 non-empty parts, and all the elements must be in one part or the other but not both. This translates to ensuring that the sum of the lengths of the parts in every partition equals 5:\n\npartns = partitions('abcde', 2)\nassert all(len(part1 + part2) == 5 for part1, part2 in partns)\n\nFurthermore, a simple combinatorial analysis can be used to count the number of such partitions of abcde into 2 parts. Choosing one part automatically fixes the other part (remember that order is not important). So the only possibilities are for one part to have a single element and the other have 4, or one part to have 2 elements and the other have 3. Hence, the number of partitions is:\n\n\\binom{5}{1} + \\binom{5}{2} = 5 + 10 = 15\npartns = partitions('abcde', 2)\nassert len(partns) == 15\n\n\n4.2 Test Infrastructure\nRecall that there are two ways to organize code in modules:\n\ncreate definitions in the module so that the module (and its namespace) can be imported and used elsewhere, or\ncreate a stand-alone script that can be executed directly by the interpreter.\n\nBlackbox testing is meant for importable modules, not scripts.\n\n4.2.1 Testing using the “main” block\nWe can add an auxiliary main block at the end of the module to test the module contents:\nif \"__name__\" == \"__main__\":\n    &lt;code for testing definitions in the module&gt;\nIn this block, we can either:\n\nuse doctests via the doctest module. Note that these tests are often very limited and depend heavily on the exact string representation of the result.\nuse assert statements as shown in the example above.\n\n\n\n4.2.2 Test function suites\nThis is the preferred and more robust mechanism to test a target module, and the tests are typically organized as follows:\ntarget_module.py\ntests\n├── test_fn1.py\n├── test_fn2.py\n└── ...\nIn this example, the test_fn*.py modules contain suites of tests meant to test various parts of target_module.py; each discrete test is generally implemented by a small function. We will use the third-party pytest package in such a test framework. Please install the package via pip on your laptops for next week!"
  },
  {
    "objectID": "week5.html",
    "href": "week5.html",
    "title": "Week 5",
    "section": "",
    "text": "A recap of basic collections\nDictionaries\nList and Dictionary Comprehension\nUsing for loops with dictionaries"
  },
  {
    "objectID": "week5.html#outline",
    "href": "week5.html#outline",
    "title": "Week 5",
    "section": "",
    "text": "A recap of basic collections\nDictionaries\nList and Dictionary Comprehension\nUsing for loops with dictionaries"
  },
  {
    "objectID": "week5.html#python-collections",
    "href": "week5.html#python-collections",
    "title": "Week 5",
    "section": "2 Python Collections",
    "text": "2 Python Collections\n\nlist: mutable; sequence\ntuple: immutable; sequence\nset: mutable but the elements must be of an immutable type; no multiplicity of elements.\nfrozenset: immutable set datatype.\n\nIn fact, sets are special cases of dictionary objects (see later)."
  },
  {
    "objectID": "week5.html#set-operations",
    "href": "week5.html#set-operations",
    "title": "Week 5",
    "section": "3 Set Operations",
    "text": "3 Set Operations\nAll standard set operations are implemented either as methods or as operators. For instance:\n\n&lt;s1&gt;.union(&lt;s2&gt;) returns the union of the sets, as does the expression &lt;s1&gt; | &lt;s2&gt;\n&lt;s1&gt;.difference(&lt;s2&gt;) returns the set containing all the elements of &lt;s1&gt; that are not in &lt;s2&gt;"
  },
  {
    "objectID": "week5.html#using-loops-to-iterate-over-collections",
    "href": "week5.html#using-loops-to-iterate-over-collections",
    "title": "Week 5",
    "section": "4 Using loops to iterate over collections",
    "text": "4 Using loops to iterate over collections\nNaturally, all Python collections are iterable, and it is possible to loop over the elements in different ways:\n\nusing indices as target variable values (for sequences)\nusing elements as target variable values"
  },
  {
    "objectID": "week5.html#dictionaries",
    "href": "week5.html#dictionaries",
    "title": "Week 5",
    "section": "5 Dictionaries",
    "text": "5 Dictionaries\nA Python dictionary object implements a mapping from immutable keys to values. The dictionary can be initialized in many ways:\n\nby creating a new, empty dictionary\nby using an existing mapping of key-value pairs\nfrom an iterable consisting of tuples of key-value pairs\nfrom a keyword-argument list\n\nThe notation &lt;dict&gt;[&lt;key&gt;] allows us to obtain (or set) the value that we want associated with &lt;key&gt; in the dictionary!\n\n\n\n\n\n\nCaution\n\n\n\nBe especially aware that (a) keys must be immutable objects, and (b) the notation with square brackets is similar to list indexing.\n\n\n\n5.1 Example\nDesign a program that reads a CSV file containing grades of students (one line per student) to obtain two dictionaries:\n\nwhere the keys are the exams (numbered from 1 through the total number of exams), and the values are the lists of grades in order of the students in the file.\nwhere the keys are the row numbers and the values are themselves nested dictionaries whose keys are student names and values are the list of grades."
  },
  {
    "objectID": "week5.html#dictionary-operations",
    "href": "week5.html#dictionary-operations",
    "title": "Week 5",
    "section": "6 Dictionary Operations",
    "text": "6 Dictionary Operations\nDictionaries support many operations, including:\n\niterators (so-called view objects) for the keys, values and items (key-value tuples)\noperations to get a value for a key (or default to one if the key does not have a value) or set a default value via setdefault\npop: removing a key (while returning the associated value, or a default if specified)\npopitem: remove the last key inserted and return the item for that key.\nupdate: add/overwrite the key-value pairs based on the argument dictionary or iterables. See the signature for details!\n\n\n6.1 Example\nHuffman encoding, one of the earliest lossless compression schemes, starts by creating a dictionary with frequency counts of the symbols in the text being compressed.\nWe will create such a dictionary for the text of Huckleberry Finn."
  },
  {
    "objectID": "week5.html#using-for-loops-with-dictionaries",
    "href": "week5.html#using-for-loops-with-dictionaries",
    "title": "Week 5",
    "section": "7 Using for loops with dictionaries",
    "text": "7 Using for loops with dictionaries\nThe different views of the dictionary (keys, values and items) can be used to iterate over dictionaries.\nBy default,\nfor &lt;target&gt; in &lt;dictionary&gt;:\n    &lt;loop body&gt;\niterates over the keys in the dictionary.\nSince the items are tuples, we can deconstruct them as follows:\nfor &lt;key&gt;, &lt;value&gt; in &lt;dictionary&gt;.items():\n    # Use &lt;key&gt; and &lt;value&gt; in the body\n\n7.1 Example (continuation of Huffman coding)\nCreate a dictionary of symbol-frequency counts in a text where the keys are ordered by incerasing frequency counts.\nHuffman encoding uses such an ordered dictionary to construct a tree that can be used to produce an optimal, prefix-free code!"
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "Week 3",
    "section": "",
    "text": "Function definition (basic)\nFormal and Actual Parameters\nLocal Variables, Scope\nName Resolution\nPositional and Keyword Arguments\nDefault Parameter Values\nName Resolution\nModules\nModule Execution\nPython Coding Style"
  },
  {
    "objectID": "week3.html#outline",
    "href": "week3.html#outline",
    "title": "Week 3",
    "section": "",
    "text": "Function definition (basic)\nFormal and Actual Parameters\nLocal Variables, Scope\nName Resolution\nPositional and Keyword Arguments\nDefault Parameter Values\nName Resolution\nModules\nModule Execution\nPython Coding Style"
  },
  {
    "objectID": "week3.html#function-definition-basic",
    "href": "week3.html#function-definition-basic",
    "title": "Week 3",
    "section": "2 Function definition (basic)",
    "text": "2 Function definition (basic)\ndef &lt;function name&gt; ([&lt;formal parameters&gt;]):\n    [&lt;docstring&gt;]\n    &lt;function body&gt;\n\n\n\n\n\n\nNote\n\n\n\nFunction definitions establish a binding between &lt;function name&gt; and un-evaluated &lt;function body&gt;. For the function to be able to participate in a function call, the body must be evaluated using the existing bindings of the actual parameters passed to the function during the call.\n\n\nWhile Python functions may seem analogous to math functions, the analogy is somewhat tenuous: e.g., the former can have side-effects (like printing something or modifying mutable objects)"
  },
  {
    "objectID": "week3.html#formal-parameters-versus-actual-parameters",
    "href": "week3.html#formal-parameters-versus-actual-parameters",
    "title": "Week 3",
    "section": "3 Formal Parameters Versus Actual Parameters",
    "text": "3 Formal Parameters Versus Actual Parameters\nFormal parameters are place-holders: in the body of the function, they stand in for objects that are specified when the function is called!\nThe objects passed to the function call are called actual parameters. In the most common usage, actual parameters are passed positionally, i.e., the values are assigned to the formals in left-to-right order before the body is executed.\nInformally, both formal and actual parameters are often referred to as arguments but there is a distinction: formal parameters have no values.\nThe process of encapsulating the function body in the definition is called lambda abstraction."
  },
  {
    "objectID": "week3.html#examples",
    "href": "week3.html#examples",
    "title": "Week 3",
    "section": "4 Examples",
    "text": "4 Examples\n\nUse lambda abstraction to create a general purpose function called symmetric_in that takes two strings as parameters and returns True if and only if one of the strings is contained in the other.\nWrite a function that takes a string as argument and checks whether it is a palindrome, i.e., reads the same forwards and backwards."
  },
  {
    "objectID": "week3.html#local-namespace-of-a-function",
    "href": "week3.html#local-namespace-of-a-function",
    "title": "Week 3",
    "section": "5 Local Namespace of a Function",
    "text": "5 Local Namespace of a Function\nA function’s local namespace:\n\nany formal parameter, or\nany variable name used on the left-hand-side of an assignment statement within the function body.\n\nAll other names referenced in the body must be resolved at the time of call, i.e. an appropriate binding must be found for it."
  },
  {
    "objectID": "week3.html#the-legb-rule-for-name-resolution",
    "href": "week3.html#the-legb-rule-for-name-resolution",
    "title": "Week 3",
    "section": "6 The LEGB rule for name resolution",
    "text": "6 The LEGB rule for name resolution\nOne of the most common errors that occur in Python programs is a NameError! This happens when Python’s rule for resolving a name fails.\nThe rule is based on lexical scope: the nested structure of the definition blocks within a program determines how names are resolved.\nIn order, LEGB\n\nLocal scope: current definition\nEnclosing scope: within any (strictly) enclosing definition\nGlobal scope: the top-level namespace (i.e. bound in the module)\nBuiltin scope: a builtin object definition\n\nQualified names, i.e., names with the dot notation, are resolved by looking at the sequence of namespaces obtained from the dots.\n\n6.1 Example\n\n\nCode\nimport math\ndef f(x):\n    print(f\"Outer f's locals: {locals()}\")\n    print(f\"Outer f's globals: {globals()}\")\n    return x+y\n\ndef g(x, z):\n    z = 10\n    def f(x, z):\n        print(f\"Enclosing f's locals: {locals()}\")\n        print(f\"Enclosing f's globals: {globals()}\")\n        return x**2 + y**2 + z\n    print(f\"Outer g's locals: {locals()}\")\n    print(f\"Outer g's globals: {globals()}\")\n    return f(x, y) % z\n\ny = 19\nprint(math.pi)\nprint(f(30))\nprint(g(y, 3))"
  },
  {
    "objectID": "week3.html#keyword-arguments",
    "href": "week3.html#keyword-arguments",
    "title": "Week 3",
    "section": "7 Keyword Arguments",
    "text": "7 Keyword Arguments\n\nArguments within the call that of the form\n\n&lt;formal&gt;=&lt;object&gt;\n\n\n\n\n\n\nImportant\n\n\n\nThe same call can have both positional and keyword arguments. However, all keyword arguments must come after any positional ones (which occur in the order given by the definition). Keyword arguments do not need to be in order!\n\n\n\n7.1 Default Parameter Values\nUsually, meant to be used with keyword arguments: the default value for that argument is specified at definition time, and any variation at the time of call is supplied as a keyword argument referencing that parameter.\n\n\n7.2 Variable number of arguments\nFunction definitions allow for any number of positional arguments (indicated by convention as a *args parameter ) and any number of keyword arguments (indicated by convention as a **kwargs parameter).\nWe will study these later after we’ve had a chance to understand tuple and dictionary datatypes."
  },
  {
    "objectID": "week3.html#examples-1",
    "href": "week3.html#examples-1",
    "title": "Week 3",
    "section": "8 Examples",
    "text": "8 Examples\n\nCheck the documentation of the pow builtin function and see how it can be called in various ways by combining positional and keyword arguments.\nRepeat the exercise for the documentation of the abs builtin function and the math.isclose function."
  },
  {
    "objectID": "week3.html#modules",
    "href": "week3.html#modules",
    "title": "Week 3",
    "section": "9 Modules",
    "text": "9 Modules\nPython source code files (with the extension .py) are called modules.\n\nimport statement allows access to the global namespace of the imported module\nwhether a module can be imported *depends on the PYTHONPATH environment variable (we will study this later). For now, you should ensure that any user-defined modules are in the same folder as the program importing them.\nimport &lt;module&gt; will import all global names within &lt;module&gt;: the bindings are referenced, e.g., as &lt;module&gt;.&lt;name&gt;\nfrom &lt;module&gt; import &lt;name&gt; allows unqualified use of &lt;name&gt;\n\n\n\n\n\n\n\nWarning\n\n\n\nAlthough allowed, you should avoid using from &lt;module&gt; import *. It can be a source of ambiguity and consequent errors in name resolution!\n\n\n\nfrom &lt;module&gt; import &lt;name&gt; as &lt;alias&gt; or import &lt;module&gt; as &lt;alias&gt; are common ways of abbreviating long names (or sub-packages which we will come across later)\na module is imported only once per interpreter session"
  },
  {
    "objectID": "week3.html#sec-execution-of-a-module",
    "href": "week3.html#sec-execution-of-a-module",
    "title": "Week 3",
    "section": "10 Execution of a Module",
    "text": "10 Execution of a Module\n\nExecution consists of evaluation of the definitions and the statements in the module.\n\nTwo ways in which a module can be used:\n\nas a source for definitions to be used in other modules (i.e., like a library)\nas a stand-alone program (or script) to be executed.\n\nIn this latter form of use, a runtime stack keeps track of function calls!\n\nthe main frame (containing global namespace definitions) is at the bottom\n\nEvery function call results in the activation of a new frame that keeps track of the local namespace of the function.\n\nnew frame is pushed on top of the calling program component’s frame\ncontrol flows to the function body after parameter bindings are performed per the call’s arguments\nwhen the function returns successfully, its frame is popped from the stack\ncontrol returns to the point of execution just after the call in the calling program’s component"
  },
  {
    "objectID": "week3.html#sec-python-coding-style",
    "href": "week3.html#sec-python-coding-style",
    "title": "Week 3",
    "section": "11 Python Coding Style",
    "text": "11 Python Coding Style\nA series of Python Enhancement Proposals (PEPs) have served as design documents describing new additions to the language as it evolved, including best practices for coding style.\n\nPEP 8, the style guide for Python code, and PEP 257, the docstring convention guide, form the basis for most best practices.\nVariations in docstrings and project- or company-specific guidelines usually try to stay close to these PEP conventions.\n\nWe will follow the PEPs fairly closely as well:\n\nvariable names (including module names and function names) in snake-case; they should begin with lowercase letters\navoid short variable names: the only place where they may be reasonable is in toy code (for demo purposes), or as index variables when multiple such variables are needed.\nconstant names should be in uppercase\nwe will use capitalized names in snake-case for classes (later + there are other style conventions associated with classes)\nfollow Google-style for docstrings\nstart using pylint or flake8 packages to check your modules for style violations! This is called linting."
  },
  {
    "objectID": "week10-11.html",
    "href": "week10-11.html",
    "title": "Weeks 10 and 11",
    "section": "",
    "text": "This is a very broad topic: we will only cover a few critical concepts to help us understand OOP in Python.\nThroughout, we will use two running examples to illustrate the concepts: a point in the two-dimensional Euclidean plane and a triangle made up of three such points.\n\nClasses, Objects and Constructors\nInstance Attributes and Methods\nSpecial Methods\nIterators and Generators\nSimple Inheritance"
  },
  {
    "objectID": "week10-11.html#object-oriented-programming-oop",
    "href": "week10-11.html#object-oriented-programming-oop",
    "title": "Weeks 10 and 11",
    "section": "",
    "text": "This is a very broad topic: we will only cover a few critical concepts to help us understand OOP in Python.\nThroughout, we will use two running examples to illustrate the concepts: a point in the two-dimensional Euclidean plane and a triangle made up of three such points.\n\nClasses, Objects and Constructors\nInstance Attributes and Methods\nSpecial Methods\nIterators and Generators\nSimple Inheritance"
  },
  {
    "objectID": "week10-11.html#classes-objects-and-constructors",
    "href": "week10-11.html#classes-objects-and-constructors",
    "title": "Weeks 10 and 11",
    "section": "2 Classes, Objects and Constructors",
    "text": "2 Classes, Objects and Constructors\nA class is essentially a datatype: it consists of a domain (the possible object instances of the class) coupled with the different operations (or methods) that can be used with the objects.\nIn Python, a class definition provides the framework for specifying a way to construct new object instances and to delineate all the attributes of such instances, including the methods that the objects can use to interact with the world.\nThe entry-point into the definition is the __init__ method (Python classes have several predefined hooks for such special methods: their names begin and end with two underscores and hence, are often referred to informally as double-under or dunder methods).\nHere is an example of a class for creating points in 2D Euclidean space: we will build up the definition piece-by-piece to illustrate several key features/principles of the OOP paradigm.\n\n\nCode\nimport math\nclass Point:\n    def __init__(self, x, y):\n        \"\"\"Defines a 2D Euclidean point\n        \"\"\"\n        self.x = float(x)\n        self.y = float(y)"
  },
  {
    "objectID": "week10-11.html#instance-attributes-and-methods",
    "href": "week10-11.html#instance-attributes-and-methods",
    "title": "Weeks 10 and 11",
    "section": "3 Instance Attributes and Methods",
    "text": "3 Instance Attributes and Methods\nSo far, the definition just tells us how to construct a new Point instance via the constructor method __init__. This is an instance method: every instance including a nascent one that is just coming to life passes an implicit first argument (traditionally named self) to such a function. In addition, the function specifies two arguments that are used to set the instance attributes x and y, the Cartesian coordinates of the point.\nThe attributes x and y belong to the instance: they can be used within the class definition, for example, if we wanted to define polar coordinates (r, \\theta) for the point with r = \\sqrt{x^2 + y^2} and ~\\theta = \\arctan{y/x}. We can do this by using a method that provides the polar coordinates:\n\n\nCode\nclass Point:\n    def __init__(self, x, y):\n    ...\n\n    def get_polar(self):\n        \"\"\"Returns polar coordinates (r, theta)\"\"\"\n        return (math.sqrt(self.x ** 2 + self.y ** 2), math.atan(self.y / self.x))\n\n\nNow, a Point object has two public attributes x and y and one public method get_polar. Any code can access these via a Point object.\n\n\n\n\n\n\nNote\n\n\n\nPython does not have the same notion of privacy or information-hiding as in other OOP langauges: to indicate that some attribute (or method) is non-public (i.e., should not be used by other code), Python uses the convention of naming it with a name that starts with an underscore (_).\n\n\nFor example, we could modify the current definition so that direct access to the coordinates is discouraged, but is provided through so-called getter and setter methods:\n\n\nCode\nfrom math import sqrt, atan\nclass Point:\n    def __init__(self, x, y):\n        self.set_x(x)\n        self.set_y(y)\n\n    def get_polar(self):\n        \"\"\"Returns polar coordinates (r, theta)\"\"\"\n        r = sqrt(self.__x ** 2 + self.__y ** 2)  # distance from origin\n        theta = atan(self.__y / self.__x)  # angle  the x-axis\n        return r, theta\n\n    def set_x(self, x):\n        self.__x = float(x)\n\n    def get_x(self):\n        return self.__x\n    ...\n\n\nAny code that tries to access the __x or __y attributes will raise an AttributeError exception, which is Python’s way of indicating that these are non-public. Note that the attributes can still be used by other parts of the class code without a problem.\n\n\n\n\n\n\nImportant\n\n\n\nEverything in Python is an object! This includes classes themselves: for instance, list, int, function etc. are classes but they are also class objects. Be sure to appreciate the distinction between class instances (members of the domain of a class, e.g. the integers 0, 1, 2 etc. that are instances of int) and class objects (e.g., the datatype int)."
  },
  {
    "objectID": "week10-11.html#special-methods",
    "href": "week10-11.html#special-methods",
    "title": "Weeks 10 and 11",
    "section": "4 Special Methods",
    "text": "4 Special Methods\nThere are some methods that can be re-defined in a class definition to ensure that the corresponding protocol is executed correctly. For example, it would be natural to print a meaningful *string representation of a Point object and this can be done by re-defining the __str__ method: the protocol is that when an object has to be printed, its __str__ method is consulted to produce the desired string that needs to be output to the standard output!\nIn the same way, it would be meaningful to add or subtract two Point objects using the + or - arithmetic operators but ensuring that the operations mean that the x and y coordinates are added (or subtracted) to yield a new Point!\n\n\nCode\nclass Point:\n    def __init__(self, x, y):\n        ...\n\n    def get_polar(self):\n        ...\n\n    def set_x(self, x):\n        ...\n\n    def get_x(self):\n        ...\n\n    def __str__(self):\n        \"\"\"Returns a printable representation\"\"\"\n        return f'Point (x={self.__x}, y={self.__y})'\n\n    def __add__(self, other):\n        \"\"\"Returns a new Point that is the sum of self and other\"\"\"\n        return Point(self.__x + other.get_x(), self.__y + other.get_y())\n\n\nWe can now use these methods as follows:\n\n\nCode\npoint_1 = Point(2.0, 5.0)\npoint_2 = Point(3.0, -1.0)\nprint(point_1)  # should print Point(x=2.0, y =5.0)\nprint(point_1 + point_2)  # should print Point(x=5.0, y=4.0)"
  },
  {
    "objectID": "week10-11.html#iterators-and-generators",
    "href": "week10-11.html#iterators-and-generators",
    "title": "Weeks 10 and 11",
    "section": "5 Iterators and Generators",
    "text": "5 Iterators and Generators\nWe now come to one of the coolest features of Python: a standard iteration protocol for stepping through an iterable collection. The protocol works as follows:\n\nApplying the iter function to the collection, we get an iterator object.\nThe iterator is like a cursor: on demand, it steps to the next element from the iterable. This is done by calling the built-in next function on the iterator object.\nwhen no further elements are available, the next function raises the StopIteration exception.\n\nStudy the following example to see what really happens under the hood when we run a for loop!\n\n\nCode\n&gt;&gt;&gt; z = [2.0, 'x']\n&gt;&gt;&gt; z_iter = iter(z)   # initialize an iterator over the list\n&gt;&gt;&gt; next(z_iter)   # get the first element from the list\n2.0\n&gt;&gt;&gt; next(z_iter)   # then, the next one\n'x'\n&gt;&gt;&gt; next(z_iter)   # Nothing left in the list, so signal the end of iteration!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration\n&gt;&gt;&gt; for element in z:   # the entire protocol from start to finish.\n    element\n2.0\n'x'\n\n\nIn summary, a for loop is designed to run the iteration protocol on the target iterable: the target variable successively takes on the next function’s return values. When the StopIteration exception is raised, the loop quits!\nAny class whose instances are meant to be collections can be programmed to implement the iteration protocol as follows:\n\nIn the class, define an __iter__ method to return an iterator object.\nensure that the iterator object’s class implements a __next__ method that correctly advances through the elements of the collection in the appropriate manner.\n\nWe can illustrate this using a Triangle class whose instances each contain three Points making up the three corners of the triangle. Now, suppose that we want the iterator for the class to step through the corners of the Triangle in non-decreasing order of distance from the origin. So, for example, if the corners x, y, and z of a Triangle object are located at coordinates (5, -1), (-1, 1) and (2, 2) respectively, we then wish to iterate through them in the order y, then z and finally x. We will show three different versions of the Triangle class to illustrate this.\n\n5.1 Triangle: Version 1\nThe iterator object is the triangle instance itself, and hence we need to have the Triangle class define both an __iter__ and __next__ method! The __iter__ method ensures that we first set up a non-public list of corners sorted by distance (the get_polar method for Point objects returns a tuple with its first component being the distance from the origin).\n\n\nCode\nclass Point:\n    ...\n\nclass Triangle:  # Version 1\n    def __init__(self, pt1, pt2, pt3):\n        \"\"\"Initializes three Point objects to be the corners\"\"\"\n        self.corners = [pt1, pt2, pt3]\n\n    def __iter__(self):\n        self.__cursor = -1\n        self.__sorted = sorted(self.corners,\n                               key=lambda pt: pt.get_polar()[0])\n        return self\n\n    def __next__(self):\n        self.__cursor += 1\n        if self.__cursor == 3:\n            raise StopIteration\n        return self.__sorted[self.__cursor]\n\ntrng = Triangle(Point(5, -1), Point(-1, 1), Point(2, 2))\nfor point in trng:\n    print(f'{point} is at distance {point.get_polar()[0]} from origin')\n\n\n\n\n5.2 Triangle: Version 2\nIf we instead make use of the builtin enumerate function to have __iter__ return an enumeration of the list of corners (after sorting the list in place by distance to the origin), then the Triangle class does not need to implement its own __next__ method. The enumeration already has the loop protocol built into it!\nNotice, however, the subtle change in the target variable in the loop: since the iterator is an enumerate object, the variable is a tuple made up of the index and the triangle corner.\n\n\nCode\nclass Triangle:  # Version 2\n    def __init__(self, pt1, pt2, pt3):\n        \"\"\"Initializes three Point objects to be the corners\"\"\"\n        self.corners = [pt1, pt2, pt3]\n\n    def __iter__(self):\n        sorted(self.corners, key=lambda pt: pt.get_polar()[0])\n        return enumerate(self.corners)\n\ntrng = Triangle(Point(5, -1), Point(-1, 1), Point(2, 2))\nfor _, point in trng:\n    print(f'{point} is at distance {point.get_polar()[0]} from origin')\n\n\n\n\n5.3 Generator functions and expressions\nA generator function creates a lazy iterator: it is especially useful in cases where we need to iterate through a large (even infinite) collection without explicitly needing the entire collection to be available.\nThe generated object implements the iteration protocol as follows. The loop in the main body of the generator function is essentially like the __next__ function in the iteration protocol, except that when a yield statement is encountered, it sends the calling code the object that is yielded and then suspends itself until the next (lazy) iteration. Here is an example.\n\n5.3.1 Triangle: Version 3\n\n\nCode\ndef corner_genrtr(triangle):\n    self.__sorted = sorted(triangle.corners,\n                           key=lambda pt: pt.get_polar()[0])\n    for corner in self__sorted:\n        yield corner\n\nclass Triangle:  # Version 3\n    def __init__(self, pt1, pt2, pt3):\n        \"\"\"Initializes three Point objects to be the corners\"\"\"\n        self.corners = [pt1, pt2, pt3]\n\n    def __iter__(self):\n        return corner_genrtr(self)\n\ntrng = Triangle(Point(5, -1), Point(-1, 1), Point(2, 2))\nfor point in iter(trng):\n    print(f'{point} is at distance {point.get_polar()[0]} from origin')\n\n\n\n\n\n\n\n\nNote\n\n\n\nObserve that the __iter__ method returns an object that is defined outside the class! This means that we can have multiple iterators being used on the same Triangle object simultaneously without the iterations interfering with one another.\n\n\n\n\n\n5.4 Generating infinite streams\nSince generator functions create lazy iterators, we can produce elements from an infinite stream on demand, without explicitly having to store such a stream, which would be impossible anyway! Here is an example:\n\ndef gen_evens():\n    val = 0\n    while True:\n        yield val  # suspends itself after this!\n        val += 2\n\nevens = gen_evens()\n\nNow, evens will produce the even numbers 0, 2, 4 etc. in sequence. Note the infinite loop in the definition: we will never have a problem with it because the iteration is lazy. The next even number will be produced on demand only when the next function is applied to evens.\nHere’s another example: a generator that returns an iterator for the Fibonacci sequence:\n\ndef fibo_iterator():\n    current, next_val = 0, 1   # the frst two Fibonacci sequence numbers\n    while True:\n        yield current\n        current, next_val = next_val, current + next_val\n\nfibonacci = fibo_iterator()\nfirst_15 = [str(next(fibonacci)) for _ in range(15)]\nprint(' '. join(first_15))\n\n\n\n5.5 Generator Expressions\nIn many situations, we want to create lazy sequences instead of list comprehensions either (a) to minimize memory usage or (b) to transform a potentially infinite stream of data in a pipeline. In such cases, generator expressions are extremely useful.\nFor example, suppose we wish to produce, on demand, a stream of Fibonacci numbers in increasing order that are also divisible by 7. The following generator expression does the trick (it looks quite similar in syntax to a list comprehension but with parentheses replacing square braces):\n\nfibonacci = fibo_iterator()\nfibs_div_by_7 = (number for number in fibonacci if number % 7 == 0)\nfor _ in range(5):\n    print(next(fibs_div_by_7))\n\nNote that fibs_div_by_7, just like fibonacci, is a lazy iterator for an infinite stream.\n\n\n\n\n\n\nCaution\n\n\n\nBe aware of a few limitations of iterators:\n\nYou can only iterate once over a collection with an iterator: it cannot be reset. A new iterator has to be created for this purpose.\nIterators can only advance forward, unlike next, there is no previous builtin function (nor a corresponding __prev__ kind of special method). If the collection is a finite sequence, then the reversed builtin function can be used to create an iterator that iterates backwards over a collection.\nwhile iterators and generators resemble sequences, one cannot use builtin functions like len to compute their length, or index into them using [] notation."
  },
  {
    "objectID": "week10-11.html#simple-inheritance",
    "href": "week10-11.html#simple-inheritance",
    "title": "Weeks 10 and 11",
    "section": "6 Simple Inheritance",
    "text": "6 Simple Inheritance\nLarge Python projects often have many classes that share common attributes and beavior, or may have small modifications in he way that they behave from other classes. To link such classes, there are two primary mechanisms: composition and inheritance. We saw an example of the former above: three Point objects are composed to form a Triangle. The latter mechanism, viz. inheritance, helps us organize code in a manner that avoids repetition and helps us classify datatypes in a natural way based on their properties.\nFor example, a triangle and a rectangle are dissimilar: one has three sides, the other four. They also have similarities in that both are examples of polygons in the plane and have areas that are related to the coordinates of the points forming the corners (see the Shoelace Formula)! So, a triangle is a polygon, as is a rectangle. On the other hand, a circle is not a polygon (well, in the limit it is one, but we’ll let that go…) but both circles and polygons are examples of planar regions that have an area.\nOne of the primary goals of OOP is to facilitate systematic development of code that works consistently across such a hierarchy of classes. For instance, the hierarchy of planar regions identified in the previous paragraph might look something like this (with an auxiliary Point class defined as above):\nPoint\n\nPlanarRegion\n    Oval\n        Circle\n    Polygon\n        Triangle\n        Rectangle\nIn OOP terminology, Polygon is the superclass of Triangle and Rectangle: they can both share the methods of the Polygon class but can add specialized attributes and methods in their own definitions that provide distinctive state and behavior. Thus, the Triangle class is a subclass of Polygon; in turn, Polygon is a subclass of PlanarRegion.\nThe Substitution Principle in OOP asserts that any subclass object can be syntactically substituted in code where a superclass object is expected. For example, every Polygon object has a length (number of sides) so it is syntactically correct to expect a Triangle object to have a length. The reverse is not true: while a Circle is an Oval, an oval object has no radius (it has a major and minor axis that are not necessarily equal) and cannot be substituted in a place where we expect to use a circle.\n\n6.1 Attributes, Methods, Information Hiding\nBuilding out the hierarchy depicted above, we observe some features of Python that help with creating rich inheritance hierarchies.\n\nPlanarRegion is an abstract class - we cannot instantiate an object directly as a PlanarRegion object. The only purpose of the class is to root the hierarchy, and to specify that all planar shapes that are derived from this class must define their own concrete area method.\nSibling classes like Oval and Polygon share the area method (because they inherit it from PlanarRegion) but also have bespoke attributes: ovals have major and minor axes, while polygons have corners.\nIt is often very easy to construct an instance of a subclass like Circle by invoking the constructor of the superclass (Oval).\nAttributes whose names begin with two underscores are non-public, and are effectively hidden from other code, including from the subclasses! For instance, a Circle object cannot access the __sem_major attribute in its parent class Oval. This mechanism does has a backdoor (since Python does not have the same philosophy of public-protected-private access that other OOP languages like Java enforce for information hiding).\n\n\nfrom abc import ABC, abstractmethod\nimport math\n\n\nclass PlanarRegion(ABC):\n    \"\"\"An abstract base class (ABC) for planar regios\"\"\"\n    @abstractmethod\n    def area(self):\n        raise NotImplementedError\n\n\nclass Oval(PlanarRegion):\n    \"\"\"An x-y axis aligned oval\"\"\"\n    def __init__(self, semi_major_axis, semi_minor_axis):\n        self.__semi_major = semi_major_axis\n        self.__semi_minor = semi_minor_axis\n\n    def area(self):\n        return math.pi * self.__semi_major * self.__semi_minor\n\n\nclass Circle(PlanarRegion):\n    def __init__(self, radius):\n        self.set_radius(radius)\n\n    def set_radius(self, radius)\n        super().__init__(radius, radius)\n        self.__radius = radius\n\n    def get_radius(self):\n        return self.__radius\n\n    def get_diameter(self):\n        return 2 * self.get_radius()\n\n\nclass Polygon(PlanarRegion):\n    \"\"\"A polygonal shape specified by corners in sequence with the\n    assumption that the sides of the polygons do not self-intersect.\n    \"\"\"\n    def __init__(self, *corners):\n        \"\"\"Set the corners of the polygon in order\"\"\"\n        self.__corners = list(corners)  # each corner is a Point\n\n    def area(self):\n        \"\"\"Implementation of the shoelace formula\"\"\"\n        return 0\n\n    def perimeter(self):\n        \"\"\"Implement this for practice!\"\"\"\n        return 0\n\n\nclass Triangle(Polygon):\n    def __init__(self, pt1, pt2, pt3):\n        super().__init__(pt1, pt2, pt3)\n\n\nclass Rectangle(Polygon):\n    def __init__(self, pt1, pt2, pt3, pt4):\n        # Implement this: ensure that the sides form a rectangle!\n        super().__init__(pt1, pt2, pt3, pt4)\n\n    def diagonal(self):\n        \"\"\"Returns the length of the diagonal of the rectangle\"\"\"\n        # Implement this\n        return 0"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus (Fall 2023)",
    "section": "",
    "text": "Catalog Number\n56:219:500 (also cross-listed as 56:198:500 and 56:121:531)\n\n\nInstructor\nSunil Shende\n\n\nSchedule\nMW from 3:45pm to 5:05pm\n\n\nClassroom\nCS-109 Cooper Classroom Building\n\n\nOffice Hours\nOn Zoom MW from 10am to 11am\n\n\nEmail\nshende AT camden DOT rutgers DOT edu"
  },
  {
    "objectID": "syllabus.html#course-information",
    "href": "syllabus.html#course-information",
    "title": "Syllabus (Fall 2023)",
    "section": "",
    "text": "Catalog Number\n56:219:500 (also cross-listed as 56:198:500 and 56:121:531)\n\n\nInstructor\nSunil Shende\n\n\nSchedule\nMW from 3:45pm to 5:05pm\n\n\nClassroom\nCS-109 Cooper Classroom Building\n\n\nOffice Hours\nOn Zoom MW from 10am to 11am\n\n\nEmail\nshende AT camden DOT rutgers DOT edu"
  },
  {
    "objectID": "syllabus.html#learning-outcomes",
    "href": "syllabus.html#learning-outcomes",
    "title": "Syllabus (Fall 2023)",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nStudents are not expected to have prior programming experience. In general, by the end of the course, it is expected that successful students will:\n\nunderstand and use appropriate programming constructs for developing Python code\ndocument and test code cleanly and robustly\napply computational and inferential thinking in program construction\nuse specific built-in Python libraries and third-party libraries for data science for computational problem solving"
  },
  {
    "objectID": "syllabus.html#textbook",
    "href": "syllabus.html#textbook",
    "title": "Syllabus (Fall 2023)",
    "section": "Textbook",
    "text": "Textbook\nWe will use the following book as our primary textbook:\n\nIntroduction to Computation and Programming Using Python, third Edition: With Application to Computational Modeling and Understanding Data, by John V. Guttag. Published by The MIT Press, 2021.\n\nYou can buy the book but it is also available online from the Rutgers Libraries site: please use your Rutgers NetID to login and access it. Please do not download and print book chapters - save the planet by not wasting unnecessary paper!\nAs a way of supplementing and complementing material from the textbook, I will also provide additional notes, links to topics on the internet or links to relevant videos."
  },
  {
    "objectID": "syllabus.html#logistics",
    "href": "syllabus.html#logistics",
    "title": "Syllabus (Fall 2023)",
    "section": "Logistics",
    "text": "Logistics\nWe will be using the Rutgers Canvas site for the course as well as Github or Google Drive to share class material. The class will run in semi-flipped mode as follows:\n\non Wednesdays, we will have a traditional lecture alongside programming and problem solving, and\non Mondays, you are expected to arrive to class having already read assigned readings and watched assigned videos (if any) for that week. In class, you will work on specific programming programming problems as a means to develop mastery, and you will submit these programs for credit."
  },
  {
    "objectID": "syllabus.html#tentative-schedule-of-topics",
    "href": "syllabus.html#tentative-schedule-of-topics",
    "title": "Syllabus (Fall 2023)",
    "section": "Tentative Schedule of Topics",
    "text": "Tentative Schedule of Topics\nPlease note that this schedule is tentative and subject to change. The weeks refer to two consecutive class sessions and not to calendar weeks, e.g. Week 1 below includes Wednesday (Sep 6) and Monday (Sep 11).\n\n\n\nWeek\nTopics\n\n\n\n\n1\nIntroduction: Variables, Datatypes, Objects; Environments\n\n\n2\nFlow of Control: Loops, Conditionals and Matching\n\n\n3\nFunctions; Exceptions; Documenting code\n\n\n4\nFunctional abstraction; Namespaces; Lists and Tuples\n\n\n5\nSequences; Dictionaries; Iterables\n\n\n6\nReading and writing files; Testing code\n\n\n7\nObject-oriented programming: Classes\n\n\n8\nUsing built-in classes and designing classes\n\n\n9\nSpecial methods; Iterators & Generators; Protocols\n\n\n10\nData Science with numpy, scipy, pandas\n\n\n11\nPlotting and Visualizing Data: matplotlib\n\n\n12\nRandomness, Sampling and Distributions\n\n\n13\nSimulation, Hypothesis Testing\n\n\n14\nReview"
  },
  {
    "objectID": "syllabus.html#grading",
    "href": "syllabus.html#grading",
    "title": "Syllabus (Fall 2023)",
    "section": "Grading",
    "text": "Grading\nThe overall grade will be apportioned based on the following assessments:\n\n30% Bi-weekly homework (drop worst grade out of 7)\n30% Weekly In-Class Assessments (omit worst 2 grades)\n40% Two in-class midterm exams\n\nExcept in the most extenuating circumstances, there will be no makeup opportunities for exams or in-class assessments. Late submission of homework problem sets will generally not be entertained except in the case of a verifiable, documented emergency (medical or personal). If you require special accommodation, e.g., extra time on the exams or in-class assessments, please obtain appropriate documents from the Division of Student Affairs.\n\nLetter grade rubric\nI generally use (with some minor variation at my discretion) the following rubric:\n\nan A grade for overall points above 85%\na B+ grade in the range 75 – 85%\na B grade in the range 65 – 75%\na C+ grade in the range 60 – 65%\na C grade in the range 50 – 60%\n\nAnything below 50% is considered an unsatisfactory or failing grade (either a D or F grade)."
  },
  {
    "objectID": "syllabus.html#academic-integrity",
    "href": "syllabus.html#academic-integrity",
    "title": "Syllabus (Fall 2023)",
    "section": "Academic Integrity",
    "text": "Academic Integrity\nSome of the in-class assessments will be collaborative, while others will need to be completed individually. There are lots of places and mechanisms whereby you can get help to solve your homework problems, but be warned that there are many gaps in reasoning and incorrect solutions in the wild (including code that you may find on websites or after consulting your favorite large language model). If challenged, you will have to be prepared to clearly explain your code and/or written submissions to my satisfaction. This is a graduate course, and a large part of being successful in graduate school lies in recognizing that learning does not come from mimicry or plagiarism.\nI strongly encourage you to learn from other books, internet resources like StackOverflow, and even by prompting LLMs like GPT-X/ CoPilot/Bard. But, you must cite your sources at all times! Copying from someone or somewhere without citation or simply allowing your work to be copied by others constitutes cheating, as does blind transcription from sources including books, LLM transcripts and the internet at large. You are ultimately responsible for what you turn in: if it is determined that your work (even with citations) is derivative and you haven’t completely understood what you have submitted, it will count as an academic integrity violation and will carry pretty serious penalties.\nI will follow the Rutgers Academic Integrity Policy and Student Code of Conduct to deal with suspected violations. Please read and understand the policy carefully."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the website for the Fall 2023 edition of Data Science 500 (56:219:500). The course is also cross-listed as CS 500 (56:198:500) and CCIB 530 (56:121:530)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science 500",
    "section": "",
    "text": "This course is cross-listed in three graduate programs at Rutgers-Camden: Data Science, CCIB and Computer Science (as a deficiency course). The overall goal is to provide a foundational introduction to programming in Python in a variety of Data Science and scientific computing application contexts. More broadly, students will be exposed to computational thinking, the basics of statistical inference and reasoning about data, and to software engineering best practices in program development, testing and documentation."
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Data Science 500",
    "section": "Contents",
    "text": "Contents\n\nSyllabus\nWeek 1\nWeek 2\nWeek 3\nWeek 4\nWeek 5\nWeek 6\nWeeks 7 and 8\nWeeks 10 and 11"
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "Week 1: Preliminaries",
    "section": "",
    "text": "Embedded devices: check mileage, monitor emissions & speed, tracks position with GPS etc.\nImaging: Medical scanning technology, flight simulators, computer gaming engines, CAD/CAM\nInformation technology: web search engines, electronic commerce, algorithmic trading\nRouting & tracking: algorithms to synchronize information from sensors, transponders, satellites and ground control to manage aircraft position, speed, altitude, and trajectory\nBiology and Medicine: Genome analysis, protein folding, vaccine development\nPublic Policy: contact tracing in pandemics, simulating disease spread and identifying smart mitigation strategies to prevent it etc."
  },
  {
    "objectID": "week1.html#programming-in-scientific-applications",
    "href": "week1.html#programming-in-scientific-applications",
    "title": "Week 1: Preliminaries",
    "section": "",
    "text": "Embedded devices: check mileage, monitor emissions & speed, tracks position with GPS etc.\nImaging: Medical scanning technology, flight simulators, computer gaming engines, CAD/CAM\nInformation technology: web search engines, electronic commerce, algorithmic trading\nRouting & tracking: algorithms to synchronize information from sensors, transponders, satellites and ground control to manage aircraft position, speed, altitude, and trajectory\nBiology and Medicine: Genome analysis, protein folding, vaccine development\nPublic Policy: contact tracing in pandemics, simulating disease spread and identifying smart mitigation strategies to prevent it etc."
  },
  {
    "objectID": "week1.html#agenda",
    "href": "week1.html#agenda",
    "title": "Week 1: Preliminaries",
    "section": "2 Agenda",
    "text": "2 Agenda\n\nGoals\nSyllabus walk-through\nSoftware & Tools\nPython basics: Variables, Expressions, Data Types, Functions, Modules\nSession Theme: Variations on computing the value of \\pi"
  },
  {
    "objectID": "week1.html#course-goals",
    "href": "week1.html#course-goals",
    "title": "Week 1: Preliminaries",
    "section": "3 Course Goals",
    "text": "3 Course Goals\n\nDevelop computational thinking skills: the ability to harness “thought processes involved in expressing solutions as computational steps or algorithms that can be carried out by a computer”\nLearn to apply logic and precision to problem solving\nBecome fluent in the basic syntax and semantics of Python\nUnderstand best practices and develop skills for documenting, testing, debugging and refining Python code (baby steps to software engineering)\n\n\nBuild a foundation for progress from a novice programmer to an expert"
  },
  {
    "objectID": "week1.html#command-line-shell",
    "href": "week1.html#command-line-shell",
    "title": "Week 1: Preliminaries",
    "section": "4 Command-Line Shell",
    "text": "4 Command-Line Shell\nIf you are not familiar with a Unix/Linux command-line shell, please take the time to learn about it! It comes pre-installed on Macs and Linux boxes as a Terminal application, and on Windows you can either install WSL 2 (Windows Subsystem for Linux) or Git Bash.\n\n\n\n\n\n\nImportant\n\n\n\nAll data scientists should know how to skillfully use a command line shell to navigate through file systems, run commands and programs, and access cloud services."
  },
  {
    "objectID": "week1.html#software-installation",
    "href": "week1.html#software-installation",
    "title": "Week 1: Preliminaries",
    "section": "5 Software Installation",
    "text": "5 Software Installation\nYou can install Anaconda which comes bundled with Python and all the Python data science-related packages that will be used in this course. It also comes with its own package manager.\n\n\n\n\n\n\nTip\n\n\n\nConsider installing Miniconda: this is a minimal installer that comes with a package management tool called conda.\n\n\nAlternatively, if you want more control over what gets installed, you can install the needed software individually:\n\nPython: Version 3.11: check that pip or pip3, the Python package management utility has been installed. On WSL2, you will need to use the default package manager called apt (for Ubuntu Linux, the default distribution installed with WSL) - see the installation directions here.\nOnce pip3 installed, you can install any Python package from the PyPi repository. For now, just make sure that jupyterlab, matplotlib, numpy, scipy and pandas are installed using pip.\n\n\n\n\n\n\n\nWarning\n\n\n\nYou should either use conda or use pip: do not use both as this can be a major source of confusion when it comes to locating exactly which version of which package is being used by your Python code!"
  },
  {
    "objectID": "week1.html#editing-programs",
    "href": "week1.html#editing-programs",
    "title": "Week 1: Preliminaries",
    "section": "6 Editing Programs",
    "text": "6 Editing Programs\nThere are basically two possibilities for writing Python code and Markdown annotations (for text explanations of the code):\n\neither a standalone or an integrated editor (called an IDE): e.g., Spyder, VS Code, Vim etc.\na browser-based editing environment called a Jupyter notebook that is either local to your laptop (via Jupyter lab) or is hosted through Google’s Colab service."
  },
  {
    "objectID": "week1.html#textbook-code",
    "href": "week1.html#textbook-code",
    "title": "Week 1: Preliminaries",
    "section": "7 Textbook code",
    "text": "7 Textbook code\nThe code demonstrated in the textbook is avaialble in a Github cloud repository.\nThis code can be downloaded. Please experiment with it while reading the corresponding chapters from the textbook."
  },
  {
    "objectID": "week1.html#python-from-30000-feet",
    "href": "week1.html#python-from-30000-feet",
    "title": "Week 1: Preliminaries",
    "section": "8 Python from 30,000 feet",
    "text": "8 Python from 30,000 feet\n\nInvented by Guido Van Rossum and first released in 1991 (named after the popular Monty Python’s Flying Circus)\nEasily the most popular high-level language with native support for different programming paradigms and excellent built-in libraries\nIt is an object-oriented programming language: we understand programs as specifications of interactions among computational objects like numbers, strings, functions, files containing data and code, fixed-length and variable-length sequences, and so forth.\nIt is an interpreted language: code is executed in interactive mode in a REPL (read-eval-print-loop) or is run as part of an application. This facilitates the rapid prototyping of code.\nIt comes with batteries included, viz. a vast ecosystem of built-in packages.\nThere are scores of really useful, third-party Python packages for data science!\nThe Zen of Python: Clean, expressive and readable programs!\nIt encourages computational thinking with intuitive and uniform protocols for iteration, handling data streams, and safely managing resources."
  },
  {
    "objectID": "week1.html#python-programs-basic-ingredients",
    "href": "week1.html#python-programs-basic-ingredients",
    "title": "Week 1: Preliminaries",
    "section": "9 Python Programs: Basic Ingredients",
    "text": "9 Python Programs: Basic Ingredients\n\nData (objects, types, names)\nStatements:\n\nAssignments\nSelection\nLoops\n\nFunctional abstraction"
  },
  {
    "objectID": "week1.html#data-types",
    "href": "week1.html#data-types",
    "title": "Week 1: Preliminaries",
    "section": "10 Data Types",
    "text": "10 Data Types\n\nSets of values with associated operations on the values\nSome primitive types in Python:\n\nInteger (int)\nFloat (float)\nString (str)\nBoolean (bool)\n\nContainer type: list, tuple, set\nMapping type: Dictionary (dict)"
  },
  {
    "objectID": "week1.html#objects-and-named-variables",
    "href": "week1.html#objects-and-named-variables",
    "title": "Week 1: Preliminaries",
    "section": "11 Objects and (Named) Variables",
    "text": "11 Objects and (Named) Variables\n\nValues (corresponding to data types) are called objects\nWe reference objects by giving them names; the names are called variables or variable names."
  },
  {
    "objectID": "week1.html#statements",
    "href": "week1.html#statements",
    "title": "Week 1: Preliminaries",
    "section": "12 Statements",
    "text": "12 Statements\nA program in Python is a sequence of statements that are evaluated step-by-step\nTypical statement types:\n\nDirective\nAssignment\nSelection\nLoop\nFunction definition …"
  },
  {
    "objectID": "week1.html#assignment",
    "href": "week1.html#assignment",
    "title": "Week 1: Preliminaries",
    "section": "13 Assignment",
    "text": "13 Assignment\nConsult the Python Tutor website to visualize the binding of values to names in a Python code snippet!\n\nAssignments bind names to values\nBinding is dynamic: the type of a value always remains unchanged, but the same name may refer to different values (and hence different types) at various times during the program execution."
  },
  {
    "objectID": "week1.html#basic-selection",
    "href": "week1.html#basic-selection",
    "title": "Week 1: Preliminaries",
    "section": "14 Basic Selection",
    "text": "14 Basic Selection\nStatement executes the selected block of code only if the boolean condition is True\nif &lt;cond&gt;:\n    &lt;selected code block&gt;\nBranching: statement executes either the selected block (exclusively) or the alternative block depending on whether the condition is True or False.\nif &lt;cond&gt;:\n    &lt;selected code block&gt;\nelse:\n    &lt;alternative code block&gt;"
  },
  {
    "objectID": "week1.html#basic-for-loop",
    "href": "week1.html#basic-for-loop",
    "title": "Week 1: Preliminaries",
    "section": "15 Basic for Loop",
    "text": "15 Basic for Loop\nPython has a repetition construct for definite loops that repeat a certain number of times:\nfor &lt;var&gt; in &lt;iterable collection&gt;:\n    &lt;code block&gt;\nThe block of code is repeatedly executed, but prior to each iteration, the variable name (in the for statement) is assigned the next value in sequence from the iterable collection.\nIteration stops when the collections runs out of values!"
  },
  {
    "objectID": "week1.html#basic-while-loop",
    "href": "week1.html#basic-while-loop",
    "title": "Week 1: Preliminaries",
    "section": "16 Basic while loop",
    "text": "16 Basic while loop\nPython also has a repetition construct for indefinite loops:\nwhile &lt;cond&gt;:\n    &lt;code block&gt;\nPrior to each iteration, the boolean condition is evaluated. If it is True, only then is the code block executed. Otherwise, iteration stops."
  },
  {
    "objectID": "week1.html#functions",
    "href": "week1.html#functions",
    "title": "Week 1: Preliminaries",
    "section": "17 Functions",
    "text": "17 Functions\nLittle pieces of code that hold a program together!\n\nAbstraction that encapsulates a piece of computation whose outcome (return value) depends on the supplied inputs (parameters or arguments)\nSeparation of code into functional units allows us to compose functions in a modular fashion (and helps with a host of other desirable software development activities)."
  },
  {
    "objectID": "week1.html#batteries-included",
    "href": "week1.html#batteries-included",
    "title": "Week 1: Preliminaries",
    "section": "18 Batteries Included",
    "text": "18 Batteries Included\nPython comes pre-loaded with library modules that already define useful data-types (classes) and functions. For example:\n\nmath: mathematical and trigonometric functions\nrandom: pseudo-random numbers and distributions for simulations and randomized computation"
  },
  {
    "objectID": "week1.html#theme-how-to-approximate-pi",
    "href": "week1.html#theme-how-to-approximate-pi",
    "title": "Week 1: Preliminaries",
    "section": "19 Theme: How to approximate \\pi",
    "text": "19 Theme: How to approximate \\pi\nWe will use the random and math builtin modules!\n\nArchimedean approximation using perimeters of regular polygons\nMadhava-Gregory-Leibnitz approximation:\ntan^{-1} (x) = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\ldots\nNilakantha approximation:\n\\frac{\\pi}{4} = \\frac{3}{4} + \\left( \\frac{1}{2 \\cdot 3 \\cdot 4} - \\frac{1}{4 \\cdot 5 \\cdot 6} + \\frac{1}{6 \\cdot 7 \\cdot 8} - \\ldots \\right)\nViete approximation:\n\\frac{2}{\\pi} = \\frac{\\sqrt{2}}{2} \\cdot \\frac{\\sqrt{2 + \\sqrt{2}}}{2} \\cdot \\frac{\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}{2} \\ldots\nBrouncker approximation:\n\\frac{\\pi}{4} = \\frac{1}{1 + \\frac{1^2}{2 + \\frac{3^2}{2 + \\frac{5^2}{2 + \\ldots}}}}\nWallis approximation:\n\\frac{\\pi}{2} = \\left( \\frac{2}{1} \\cdot \\frac{2}{3} \\right) \\cdot \\left( \\frac{4}{3} \\cdot \\frac{4}{5} \\right) \\cdot \\left( \\frac{6}{5} \\cdot \\frac{6}{7} \\right) \\ldots\nMonte Carlo simulation using random darts\nMonte Carlo simulation using needles crossing horizontal lines"
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "Week 2",
    "section": "",
    "text": "This week, we take a deeper dive into basic data types in Python, conditional statements and loops, and simple function definitions.\n\nExpressions\nStrings\nAssignments and Bindings\nFunction definitions (basics)\nif-elif-else statements\nfor loops\nwhile loops"
  },
  {
    "objectID": "week2.html#outline",
    "href": "week2.html#outline",
    "title": "Week 2",
    "section": "",
    "text": "This week, we take a deeper dive into basic data types in Python, conditional statements and loops, and simple function definitions.\n\nExpressions\nStrings\nAssignments and Bindings\nFunction definitions (basics)\nif-elif-else statements\nfor loops\nwhile loops"
  },
  {
    "objectID": "week2.html#bookmark-these-sites",
    "href": "week2.html#bookmark-these-sites",
    "title": "Week 2",
    "section": "2 Bookmark these sites!",
    "text": "2 Bookmark these sites!\nThe official Python Documentation. From here you can navigate to:\n\nThe Python Tutorial\nThe Python Standard Library\nThe Python Module Index"
  },
  {
    "objectID": "week2.html#expressions",
    "href": "week2.html#expressions",
    "title": "Week 2",
    "section": "3 Expressions",
    "text": "3 Expressions\nExpressions are composed from variables, values and operators. Some examples of operators are:\n\nArithmetic operators: +, -, / (true division), // (integer division leaving a quotient), *, % (remainder in integer division) etc.\nLogical operators: and, or, not etc.\nSequence operators: [] (indexing or slicing), + (concatenation), * (replication) etc.\nCall expressions: using previously defined functions.\n\n\n\n\n\n\n\nNote\n\n\n\nDatatypes are implemented in Python as classes. Functions that are associated with a datatype value are called methods.\n\n\n\n3.1 Exercise: Leap Year Calculation\nA year is a leap year if it is divisible by 4 but not divisible by 100 unless it is divisible by 400. For instance, 2004 is a leap year, 1900 is not, but 2000 is.\nSuppose that a variable year holds an integer that represents a year. Construct an expression that would be true if and only if year is a leap year.\n\n# Ask user to input a year and store the integer in variable `year`\n\n# Construct the expression for `year` being a leap year"
  },
  {
    "objectID": "week2.html#expression-evaluation",
    "href": "week2.html#expression-evaluation",
    "title": "Week 2",
    "section": "4 Expression Evaluation",
    "text": "4 Expression Evaluation\nThe Python interpreter evaluates expressions in the context of an environment.\n\nEnvironment: Collection of bindings of names to values.\n\nPython’s environment is dynamic: every added definition or assignment changes it!\nAll builtin bindings (e.g., functions like len, bin, str, int) are available to the interpreter in the main environment."
  },
  {
    "objectID": "week2.html#strings",
    "href": "week2.html#strings",
    "title": "Week 2",
    "section": "5 Strings",
    "text": "5 Strings\nPython’s strings are Unicode strings: symbols from all known languages, glyphs and synthesized symbols can be used in a Python string! For instance: '\\u03C0', '\\U0001f644'\nInternally, strings are encoded into bytes, e.g., using the UTF-8 encoding. Printing a string involves decoding the string.\n\n\n\n\n\n\nNote\n\n\n\nData can occur in all kinds of formats/encodings. It is important to understand some of the history of encodings: even if you might not understand some of the details, please check out Ned Batchelder’s PyCon 2012 presentation on Unicode in Python.\n\n\n\nImmutable: Operations on string operands create new strings.\n\nExamples of string operations: length, concatenation, replication, indexing, slicing.\n\n5.1 Exercise\n\n# Start with the string x whose value is 'Data '.\n\n# Find its length.\n\n# Obtain the string y with value 'Data Science' from x\n\n# Replicate y 5 times\n\n# Find the index of the second occurrence of 'a' in y\n\n# Find the string made up of every other character from y\n\nA program in Python is a sequence of statements that are evaluated from top to bottom.\n\n\n\n\n\n\nImportant\n\n\n\nEvaluation of a statement causes one or more of the following effects:\n\nchange in state of existing variable(s): new binding(s)\naddition of new variables to the current environment’s namespace: new definitions\ncreation of a new frame as a result of a function call"
  },
  {
    "objectID": "week2.html#assignment-statement",
    "href": "week2.html#assignment-statement",
    "title": "Week 2",
    "section": "6 Assignment Statement",
    "text": "6 Assignment Statement\n\n\n\n\n\n\nTip\n\n\n\nUse the Python Tutor website to visualize the binding of values to names in a Python code snippet!\n\n\n\nAssignments bind names to values\nBinding is dynamic: the type of a value always remains unchanged, but the same name may refer to different values (and hence different types) at different times during the program execution.\n\n\n6.1 Exercise\nCompute the approximate acceleration of gravity for an object above the earth’s surface, assigning accel_gravity with the result. The expression for the acceleration of gravity is: (G \\cdot M) / (d^2), where G is the gravitational constant 6.673 \\times 10^{-11}, M is the mass of the earth 5.98 \\times 10^{24} (in kg), and d is the distance in meters from the Earth’s center (stored in variable dist_center).\nYour code should ask for the distance to be entered as input, and should print the acceleration accurate to 2 decimal places."
  },
  {
    "objectID": "week2.html#import-statement",
    "href": "week2.html#import-statement",
    "title": "Week 2",
    "section": "7 import statement",
    "text": "7 import statement\nMain purpose: augment the current namespace with additional name bindings obtained from the module being imported.\n\nadd definitions of constants, functions and data types (classes) from built-in Python libraries\nadd auxiliary code developed for an application\n\n\n\n\n\n\n\nWarning\n\n\n\nAvoid namespace pollution: use qualified names via dot notation, e.g., math.pi\n\n\n\n7.1 Exercise\nImport the fractions module.\n\nUse the dir builtin function to see what is defined in the module\nUse the help builtin function to get documentation on a specific definition, e.g. the fractions.Fraction datatype\nExperiment with different operations on fractions"
  },
  {
    "objectID": "week2.html#function-definition",
    "href": "week2.html#function-definition",
    "title": "Week 2",
    "section": "8 Function Definition",
    "text": "8 Function Definition\nEncapsulates a piece of computation whose outcome (return value) depends on the supplied inputs (parameters or arguments)\nSeparation of code into functional units allows us to:\n\ncompose functions in a modular fashion\ncreate clean interfaces between parts of code\npractice the DRY principle (Don’t repeat yourself)\ntest code in small, manageable units\n\n\n8.1 Exercise\n\nDefine a function that computes the hypotenuse of a right-angle triangle given its legs by using the Pythagorean theorem.\nFollow documentation guidelines: create a docstring\nUse the doctest module to create simple tests for the function within the docstring.\n\n\n\nThe pass statement is a placeholder and does nothing!\nNever test two real (i.e. float) values for equality! Use math.isclose instead.\n\n\n\ndef hypotenuse(leg_1, leg_2):\n    pass"
  },
  {
    "objectID": "week2.html#selection-statement-if-elif-else",
    "href": "week2.html#selection-statement-if-elif-else",
    "title": "Week 2",
    "section": "9 Selection statement: if-elif-else",
    "text": "9 Selection statement: if-elif-else\nSometimes referred to as a multi-way branch.\nif &lt;condition 1&gt;:\n    &lt;code block 1&gt;\nelif &lt;condition 2&gt;:\n    &lt;statement block 2&gt;\n...\nelse:\n    &lt;default code block&gt;\n\n&lt;code block 1&gt; is only evaluated if &lt;condition 1&gt; is True\nIn general, &lt;code block n&gt; is only evaluated if all the conditions for preceding blocks are False and &lt;condition n&gt; is True\nIf control reaches else, &lt;default code block&gt; is executed.\nControl flows out of the selection statement after a selected code block (or the default block) is executed.\n\n\n9.1 Exercise\nThe surface gravity on the Moon is 1.62 ~m/s^2; on Mars, it is 3.711 ~m/s^2; and on Earth it is 9.807 ~m/s^2. Write a Python script that asks the user to enter either “Moon”, “Earth” or “Mars” at a prompt, and computes the weight in Newtons of a 180 lb. person on that planetary body."
  },
  {
    "objectID": "week2.html#for-loops",
    "href": "week2.html#for-loops",
    "title": "Week 2",
    "section": "10 for Loops",
    "text": "10 for Loops\nfor &lt;var&gt; in &lt;iterable collection&gt;:\n    &lt;code block&gt;\n\n&lt;var&gt; is also called the loop control target.\nAt the start of each iteration, &lt;var&gt; is bound to the next value from the &lt;iterable collection&gt;. When there is no such value available, control flows out of the loop.\nDuring the iteration, the &lt;code block&gt; of code is executed. Then control flows back to the beginning of the loop.\n\n\n10.1 Exercise\nWrite a function that takes a non-negative integer as an argument. It should return a count of the number of even digits in the number.\n\ndef count_even_digits(num):\n    \"\"\"Returns number of even digits in num\n\n    Args:\n        num (int): a non-negative integer\n\n    Returns:\n        int\n    \"\"\"\n    pass\n\n\n\n10.2 Exercise: Reading test files\nWrite a program that reads a text file alice_wonderland.txt in the same directory as the program (e.g., the notebook). It should print the percentage of lines that mention Alice.\n\n\n\n\n\n\nNote\n\n\n\nThe builtin open function can be used to open a text file for reading from or writing into the file. The resulting object provides an iterable collection of lines in the file."
  },
  {
    "objectID": "week2.html#while-loop",
    "href": "week2.html#while-loop",
    "title": "Week 2",
    "section": "11 while loop",
    "text": "11 while loop\nThis implememts indefinite iteration controlled by a boolean condition (called a predicate):\nwhile &lt;condition&gt;:\n    &lt;code block&gt;\n\n&lt;condition&gt; is tested at the beginning of an iteration\nif True, the iteration proceeds by executing &lt;code block&gt;. Flow of control then reverts back to beginning of the loop.\nif False, control flows out of the loop"
  },
  {
    "objectID": "week2.html#break-and-continue-statements",
    "href": "week2.html#break-and-continue-statements",
    "title": "Week 2",
    "section": "12 break and continue statements",
    "text": "12 break and continue statements\nbreak or continue statements may occur inside a loop body.\n\nbreak: Immediately terminates the nearest enclosing loop: if it is a for loop, the loop control target keeps its current value.\ncontinue: Forces control to revert to the start of the next iteration of the loop.\n\n\n12.1 Exercise\nDefine a function that takes as input parameters a text file and a string. The function should print the first line, if any, that contains the given string as a substring. It should return the number of lines read before such a line (if it exists) is found.\n\n\n\n\n\n\nWarning\n\n\n\nFilenames, when written as strings, are often paths in the underlying operating system. It is bad practice to pass such paths to functions that expect name of files! Do so only when you know that the file is in the same directory as the program.\n\n\n\ndef find_string(filename, phrase):\n    \"\"\"Returns the number of lines in the file prior to the first occurrence of phrase.\n\n    The function also prints the first line that contains the phrase\n\n    Args:\n        filename (str): name of text file in the program's directory\n        phrase (str): the phrase being searched\n\n    Returns:\n        int\n    \"\"\"\n    pass\n\n\n\n12.2 Exercise\nDefine a function that takes as argument a non-negative integer and returns the sum of the individual digits of its argument.\n\ndef sum_of_digits(n):\n    \"\"\"Returns the sum of the digits on n\n\n    Args:\n        n (int): non-negative integer\n\n    Returns:\n        int\n    \"\"\"\n    pass\n\n\n\n12.3 Exercise\nFrom Wikipedia:\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows: start with any positive integer n. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nAsk the user to input a non-negative integer x, and determine the length of x’s Collatz sequence (which starts at x and ends at 1).\n\n\n12.4 Exercise\nUse the random module to compute the approximate value of \\pi.\nIntution: Throw darts randomly (but uniformly) in a square with side length 2. Count the proportion of darts that land in the incircle for the square (i.e., the inscribed circle)."
  },
  {
    "objectID": "week4.html",
    "href": "week4.html",
    "title": "Week 4",
    "section": "",
    "text": "Module Creation, Execution and Linting\nModule Execution\nPython Coding Style\nLists\nCommon Sequence Operations"
  },
  {
    "objectID": "week4.html#outline",
    "href": "week4.html#outline",
    "title": "Week 4",
    "section": "",
    "text": "Module Creation, Execution and Linting\nModule Execution\nPython Coding Style\nLists\nCommon Sequence Operations"
  },
  {
    "objectID": "week4.html#module-creation-execution-and-linting",
    "href": "week4.html#module-creation-execution-and-linting",
    "title": "Week 4",
    "section": "2 Module Creation, Execution and Linting",
    "text": "2 Module Creation, Execution and Linting\nSee the notes from Module Execution and Style Guidelines, the last two sections in Week3.\nInstall the Python package pylint:\n\n% pip install pylint\n\nWe will follow the style guidelines to develop code for an assigned exercise, first in a notebook and then in a module. We will also see the benefits of linting the code to ensure that style guidelines are being adequately followed.\n\n2.1 Exercise\nSecure passwords are a first line of defense while protecting information stored on a device or stored online. Suppose we wish to device a program that validates a password through an interactive dialog. For our purposes, a valid password follows these rules:\n\nit is at least 10 characters long\nit contains at least one uppercase, one lowercase and one special character from among @, #, $, %, ^, &, and *.\nit contains at least two occurrences of digits that are separated by other non-digit characters in the password.\n\nWrite a function is_valid that takes a single string-valued (formal) parameter password and returns True if the string conforms to a legal password as per our rules, or returns False otherwise."
  },
  {
    "objectID": "week4.html#sequence-datatypes",
    "href": "week4.html#sequence-datatypes",
    "title": "Week 4",
    "section": "3 Sequence Datatypes",
    "text": "3 Sequence Datatypes\nThe str datatype is a sequence datatype, but it is immutable. Another immutable sequence type is tuple, which is a collection of fixed length or arity.\n\nCannot use assignment to modify elements in an immutable sequence.\n\nThe list datatype is also a sequence datatype. Lists are mutable collections: they can change over time.\n\n\n\n\n\n\nCaution\n\n\n\nLists are not sets; there is a separate collection type called set in Python! Thus, an element can occur more than once in a list, but only occurs at most once in a set."
  },
  {
    "objectID": "week4.html#list-creation",
    "href": "week4.html#list-creation",
    "title": "Week 4",
    "section": "4 List Creation",
    "text": "4 List Creation\n\nlist(): constructs an empty list and returns a reference to it\nThe literal []: this is not the preferred way to create a new list.\n\nMany commonly used builtin library functions return lists:\n\n&lt;string&gt;.split(&lt;separator&gt;) will return a list of strings obtained by splitting &lt;string&gt; using the substring &lt;separator&gt; (the default is to split by whitespace)\n&lt;file_handle&gt;.readlines() returns a list of lines in a file being read (from the current read position in the file)"
  },
  {
    "objectID": "week4.html#list-operations",
    "href": "week4.html#list-operations",
    "title": "Week 4",
    "section": "5 List Operations",
    "text": "5 List Operations\nList elements are numbered from 0 to the length of the list - 1. These numbers are the indices (or positions).\n\nAn out-of-range error called IndexError occurs if we try to use an index that does not exist for a list!\n\n\nlen(&lt;list&gt;): returns the length of list\n&lt;list&gt;[&lt;index&gt;]: returns the element at the given index in list\n&lt;list&gt;[&lt;slice&gt;]: returns a fresh list corresponding to the sliced portion\n&lt;list&gt;.append(&lt;element&gt;): inserts &lt;element&gt; at the end of list\n&lt;list&gt;.insert(&lt;index&gt;, &lt;element&gt;): a more general version of append; inserts just before the position given by &lt;index&gt;\n&lt;element&gt; in &lt;list&gt;: boolean expression for membership in list\n&lt;list&gt;.index(&lt;element&gt;): returns the smallest index where element is found; else raises a ValueError exception\n&lt;list&gt;.pop([&lt;index&gt;]): removes the element at the given index (or, by default, the last element if no position is not specified); subsequent elements “move up” in the list.\nlist&gt;.remove(&lt;element&gt;): removes the first occurrence (if any) of the element from list; raises ValueError if not found.\n\n\n\n\n\n\n\nNote\n\n\n\nPython has a bunch of builtin exceptions - these are errors that are raised in code when something goes wrong. These exceptions have descriptive names that generally provide a clear idea as to what may have gone wrong: e.g., AssertionError, ValueError, , IndexError, TypeError etc."
  },
  {
    "objectID": "week4.html#example",
    "href": "week4.html#example",
    "title": "Week 4",
    "section": "6 Example",
    "text": "6 Example\n\nFind the cumulative sum of numbers in a list\nRead a CSV file\nCount the number of times that Tom Sawyer (‘Tom’) is referenced in various chapters of “Huckleberry Finn”"
  },
  {
    "objectID": "week4.html#list-aliasing",
    "href": "week4.html#list-aliasing",
    "title": "Week 4",
    "section": "7 List Aliasing",
    "text": "7 List Aliasing\nAn assignment sequence\n&lt;var_1&gt; = &lt;list&gt;\n&lt;var_2&gt; = &lt;var_1&gt;\ndoes not make a fresh copy of the list: it simply creates an alias or another named reference, &lt;var_2&gt; to the list. Any changes made via one of the references affects the value of the other!\n\n\nCode\nlist_1 = [1,2,3,4]\nlist_2 = list_1\nlist_3 = list_1[1:3]\nlist_1.append(5)\nlist_1[2] = 10"
  },
  {
    "objectID": "week4.html#deep-copying",
    "href": "week4.html#deep-copying",
    "title": "Week 4",
    "section": "8 Deep Copying",
    "text": "8 Deep Copying\nAs structured datatype values become more complex (i.e. nested), it is even more important to think through the consequences of aliasing when these values are copied.\nTo make a “shallow” copy of the list, you can either do the following:\n&lt;var_2&gt; = &lt;var_1&gt;[:]\nor, import the copy builtin module and:\nimport copy\n&lt;var_2&gt; = copy.copy(&lt;var_1&gt;)\nFor a “deep” copy:\nimport copy\n&lt;var_2&gt; = copy.deepcopy(&lt;var_1&gt;)"
  },
  {
    "objectID": "week4.html#sec-sequence-operations",
    "href": "week4.html#sec-sequence-operations",
    "title": "Week 4",
    "section": "9 Sequence Operations",
    "text": "9 Sequence Operations\nPython sequence types have several operations in common with other sequence types: the list of sequence operations includes slicing, concatenation, indexing and so on."
  },
  {
    "objectID": "week4.html#example-1",
    "href": "week4.html#example-1",
    "title": "Week 4",
    "section": "10 Example",
    "text": "10 Example\nRead a CSV file of grades: it contains columns starting with the student name, and the grades on assignments. Compute the mean values of these scores."
  },
  {
    "objectID": "week6.html",
    "href": "week6.html",
    "title": "Week 6",
    "section": "",
    "text": "Practice with dictionaries\nFunctions with a variable number of arguments and with keyword arguments\nLambda Functions and higher-order programming\nSome interesting collections datatypes"
  },
  {
    "objectID": "week6.html#outline",
    "href": "week6.html#outline",
    "title": "Week 6",
    "section": "",
    "text": "Practice with dictionaries\nFunctions with a variable number of arguments and with keyword arguments\nLambda Functions and higher-order programming\nSome interesting collections datatypes"
  },
  {
    "objectID": "week6.html#python-collections",
    "href": "week6.html#python-collections",
    "title": "Week 6",
    "section": "2 Python Collections",
    "text": "2 Python Collections\n\nlist: mutable; sequence\ntuple: immutable; sequence\nset: mutable but the elements must be of an immutable type; no multiplicity of elements.\nfrozenset: immutable set datatype.\n\nIn fact, sets are special cases of dictionary objects (see later)."
  },
  {
    "objectID": "week6.html#set-operations",
    "href": "week6.html#set-operations",
    "title": "Week 6",
    "section": "3 Set Operations",
    "text": "3 Set Operations\nAll standard set operations are implemented either as methods or as operators. For instance:\n\n&lt;s1&gt;.union(&lt;s2&gt;) returns the union of the sets, as does the expression &lt;s1&gt; | &lt;s2&gt;\n&lt;s1&gt;.difference(&lt;s2&gt;) returns the set containing all the elements of &lt;s1&gt; that are not in &lt;s2&gt;"
  },
  {
    "objectID": "week6.html#using-loops-to-iterate-over-collections",
    "href": "week6.html#using-loops-to-iterate-over-collections",
    "title": "Week 6",
    "section": "4 Using loops to iterate over collections",
    "text": "4 Using loops to iterate over collections\nNaturally, all Python collections are iterable, and it is possible to loop over the elements in different ways:\n\nusing indices as target variable values (for sequences)\nusing elements as target variable values"
  },
  {
    "objectID": "week6.html#dictionaries",
    "href": "week6.html#dictionaries",
    "title": "Week 6",
    "section": "5 Dictionaries",
    "text": "5 Dictionaries\nA Python dictionary object implements a mapping from immutable keys to values. The dictionary can be initialized in many ways:\n\nby creating a new, empty dictionary\nby using an existing mapping of key-value pairs\nfrom an iterable consisting of tuples of key-value pairs\nfrom a keyword-argument list\n\nThe notation &lt;dict&gt;[&lt;key&gt;] allows us to obtain (or set) the value that we want associated with &lt;key&gt; in the dictionary!\n\n\n\n\n\n\nCaution\n\n\n\nBe especially aware that (a) keys must be immutable objects, and (b) the notation with square brackets is similar to list indexing.\n\n\n\n5.1 Example\nDesign a program that reads a CSV file containing grades of students (one line per student) to obtain two dictionaries:\n\nwhere the keys are the exams (numbered from 1 through the total number of exams), and the values are the lists of grades in order of the students in the file.\nwhere the keys are the row numbers and the values are themselves nested dictionaries whose keys are student names and values are the list of grades."
  },
  {
    "objectID": "week6.html#dictionary-operations",
    "href": "week6.html#dictionary-operations",
    "title": "Week 6",
    "section": "6 Dictionary Operations",
    "text": "6 Dictionary Operations\nDictionaries support many operations, including:\n\niterators (so-called view objects) for the keys, values and items (key-value tuples)\noperations to get a value for a key (or default to one if the key does not have a value) or set a default value via setdefault\npop: removing a key (while returning the associated value, or a default if specified)\npopitem: remove the last key inserted and return the item for that key.\nupdate: add/overwrite the key-value pairs based on the argument dictionary or iterables. See the signature for details!\n\n\n6.1 Example\nHuffman encoding, one of the earliest lossless compression schemes, starts by creating a dictionary with frequency counts of the symbols in the text being compressed.\nWe will create such a dictionary for the text of Huckleberry Finn."
  },
  {
    "objectID": "week6.html#using-for-loops-with-dictionaries",
    "href": "week6.html#using-for-loops-with-dictionaries",
    "title": "Week 6",
    "section": "7 Using for loops with dictionaries",
    "text": "7 Using for loops with dictionaries\nThe different views of the dictionary (keys, values and items) can be used to iterate over dictionaries.\nBy default,\nfor &lt;target&gt; in &lt;dictionary&gt;:\n    &lt;loop body&gt;\niterates over the keys in the dictionary.\nSince the items are tuples, we can deconstruct them as follows:\nfor &lt;key&gt;, &lt;value&gt; in &lt;dictionary&gt;.items():\n    # Use &lt;key&gt; and &lt;value&gt; in the body\n\n7.1 Example (continuation of Huffman coding)\nCreate a dictionary of symbol-frequency counts in a text where the keys are ordered by increasing frequency counts.\nHuffman encoding uses such an ordered dictionary to construct a tree that can be used to produce an optimal, prefix-free code!"
  }
]